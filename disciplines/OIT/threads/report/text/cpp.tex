\section[%
Средства стандартной библиотеки языка C++ для \\
организации многопоточных вычислений]{%
  СРЕДСТВА СТАНДАРТНОЙ БИБЛИОТЕКИ \\
  ЯЗЫКА C++ ДЛЯ ОРГАНИЗАЦИИ \\
  МНОГОПОТОЧНЫХ ВЫЧИСЛЕНИЙ
}

\subsection{Парадигма RAII}

Как известно, язык C++ является надмножеством языка C,
а стандартная библиотека языка C не содержит средств для
организации многопоточных вычислений.
Подобно \textit{libc}, стандартная библиотека языка C++
долгое время также не содержала средств для написания многопоточного кода.
По-видимому, предполагалось, что интерфейсов, предоставляемых различными ОС
C++-разработчикам будет достаточно.
Действительно, можно утверждать, что \textit{Pthreads} определяет интерфейс,
достаточный для разработки многопоточных программ любой сложности.

В подразделе~\ref{subsubsec:pthreads_mutex} было отмечено, что при работе
с примитивами синхронизации необходимо соблюдать два правила:
\begin{itemize}
\item каждый примитив синхронизации, захваченный потоком,
  должен им освобождаться;
\item захват и освобождение множества примитивов синхронизации
  должны осуществляться симметрично во избежание взаимоблокировок.
\end{itemize}
К сожалению, соблюдение этих правил при использовании всякого процедурного
интерфейса управления потоками (в том числе и \textit{Pthreads}) в реальных
приложениях является затруднительным. Даже малейшее их нарушение
приводит к трудноуловимым ошибкам в работе ПО.

Ключевой парадигмой языка C++ является RAII
(англ. Resource Aquistition Is Initialization).
Данная парадигма утверждает, что для управления ресурсами:
памятью, открытыми файлами, соединениями с БД, и~т.~д.,
должны использоваться специальные объекты,
конструкторы которых должны осуществлять захват ресурсов,
а деструкторы --- освобождение.
В этом случае ресурсы, захваченные объектами, созданными на стеке,
будут гарантированно освобождены в случае выхода из функции или
возникновении исключительной ситуации~\cite{Stroustrup:1995:DEC:193198}.

Стандарт языка C++, опубликованный в 2011 году (C++11) описывает
программный интерфейс базовых средств организации многопоточных вычислений.
Данный стандарт является шагом вперед по сравнению с \textit{Pthreads}
вперед по друм причинам:
\begin{itemize}
  \item поскольку C++11 является стандартом языка,
    обязательным для реализации разработчиками компиляторов языка С++,
    поддержка описанного в нем программного интерфейса теперь является
    частью самого языка, а не отдельной операционной системы;
  \item поскольку программный интерфейс управления потоками был
    разработан в соответствии с RAII, его использование позволяет
    значительно сократить число ошибок программирования.
\end{itemize}

Отметим, что интерфейс работы с потоками в C++ описан в
заголовочных файлах \textit{<thread>}, \textit{<mutex>},
\textit{<condition>} и \textit{<future>}.
В следующих подразделах выполнено краткий обзор их содержания.

\subsection{Базовые средства управления потоками}

К базовым средствам управления потоками стандартной библиотеки
будем относить средства, которые были ранее стандартизированы комитетом POSIX:
потоки, мьютексы, условные переменные~\cite{cppreference_thread}.
Отметим, что семафоры в этот список не входят.

Рассмотрим стандартный программный интерфейс управления жизненным циклом потока.
Поскольку поток выполнения рассматривается как ресурс, ему соответствует
объект типа \textit{std::thread}. Данный объект обладает следующими методами:
\begin{itemize}
\item \textit{get\_id} --- возращает уникальный идентификатор потока;
\item \textit{joinable} --- возвращает \textit{true}, если поток является
  \textit{joinable};
\item \textit{join} --- блокирует текущий поток а ожидании окончания работы
  данного объекта-потока;
\item \textit{detach} --- выполняет перевод данного объекта-потока в состояние
  \textit{detached}.
\end{itemize}

В дополнение к этому, стандарт определяет ряд функций, позволяющих управлять
поведением текущего потока:
\begin{itemize}
\item \textit{yield} --- используется для того, чтобы уступить вычислительные
  ресурсы другим потокам;
\item \textit{get\_id} --- для получения идентификатора текущего потока;
\item \textit{sleep\_for} и \textit{sleep\_until} --- для блокирования
  текущего потока на некоторый промежуток времени или до наступления
  некоторого момента времени в будущем.
\end{itemize}

Работа с мьютексами осуществляется путем использования объектов
типов \textit{*\_mutex}:
\textit{mutex}, \textit{timed\_mutex},
\textit{recursive\_mutex}, \textit{recursive\_timed\_mutex}.
Каждый из этих объектов предоставляет методы для
блокирующего (\textit{lock}) и неблокирующего (\textit{try\_lock})
захватов мьютекса, а также для его освобождения (\textit{unlock}).
\textit{Timed}-версии мьютексов позволяют указать максимальное время,
в течение которого должны осуществляться попытки захвата в абсолютных
или относительных единицах.

Захват и освобождение мьютексов могут также производиться в рамках
парадигмы RAII. Для этого предназначены типы \textit{lock\_guard} и
\textit{unique\_lock}. Объекты данных типов выполняют захват связанного
мьютекса в своих конструкторах, а освобождение --- в деструкторах.

Функции \textit{lock} и \textit{try\_lock} предназначены для
отложенного захвата нескольких мьютексов с их последующим
симметричным освобождением.

Условные переменные представлены типами \textit{condition\_variable}
и \textit{condition\_variable\_any}.
Они отличаются тем, что первая из них способна работать
только с \textit{unique\_lock}.
Функция \textit{notify\_all\_at\_thread\_exit} предназначена для
того, чтобы данный поток по окончании своей работы
разблокировал все потоки, связанные с условной переменной,
переданной в качестве аргумента.

На рисунке~\ref{lst:cpp_condition} представлена программа,
написанная на C++, функционально аналогичная
программе~\ref{lst:pthreads_condition}.

\lstinputlisting[
    caption=Использование условной переменной в языке С++,
    language={C++},
    label=lst:cpp_condition,
]{lst/cpp_condition.cpp}

Отметим, что код программны, написанной на C++,
значительно легче читается и является более лаконичным.

\subsection{Дополнительные средства управления потоками}

В дополнение к уже рассмотренным средствам, стандартная библиотека
C++ предоставляет высокоуровневое средство организации
вычислительного процесса, называемое \textit{futures}.
Оно предназначено для организации удобной передачи возращаемых значений,
в вызывающий поток.
Опишем типичный сценарий работы с ним:
\begin{enumerate}
\item Вызывающий поток создает объект \( p \) типа \textit{promise},
  получает доступ к связанному с ним объекту  \( f \) типа \textit{future}
  с помощью метода \textit{p.get\_future},
  передает в вызываемый поток \( p \) и блокируется в ожидании получить
  результатирующее значение с помощью \textit{p.get}.
\item Вызываемый поток выполняет вычисления и сохраняет их результат
  в \textit{promise}, используя метод \textit{p.set\_value}.
\item Вызывающий поток разблокируется и получает значение вычислений
  в качестве результата вызова \textit{p.get}.
\end{enumerate}

Отметим, что подобным образом можно передавать в вызывающий поток
не только значения, но и исключения, возникающие в вызывываемом потоке.
Перечислим средства, предназначенные для упрощения программирования
наиболее типичных сценариев работы с \textit{futures}:
\begin{itemize}
\item объекты класса \textit{packaged\_task} --- оборачивают указанный
  вызываемый объект (функцию или функтор), ставя в соответствие
  его возвращаемому значению \textit{future};
\item функция \textit{async} вызывает указанную функцию или функтор,
  возвращая результат ее выполнения в виде \textit{future}.
\end{itemize}
