\section[Стандарт реализации потоков выполнения POSIX]{%
  СТАНДАРТ РЕАЛИЗАЦИИ ПОТОКОВ \\
  ВЫПОЛНЕНИЯ POSIX}

В прошлом программные интерфейсы управления потоками,
предоставляемые различными операционными системами, существенно различались.
Этот факт значительно усложнял написание кроссплатформенных программ.
В 1995 году был разработан и опубликован стандарт
программного интерфейса потоков IEEE POSIX 1003.c.
Он представляет собой набор связанных типов, функций и констант
языка C, позволяющих управлять жизненным циклом потоков
и выполнять их синхронизацию.
На данный момент программные интерфейсы упрвления потоками,
предоставляемые практически всеми операционными системами
на базе UNIX, являются POSIX-совместимыми~\cite{pthreads_programming}.

В соответствии со стандартом, программный интерфейс управления потоками
POSIX (Pthreads) описан в заголовочном файле \textit{<pthreads.h>}.
Следует отметить, что данный заголовочный файл не является частью
стандартной библиотеки языка C.

\subsection{Управление жизненным циклом потока}

Перечислим основные функции и типы данных стандарта Pthreads,
предназначенные для управления потоками.

Функция \textit{pthread\_create()} предназначена для создания и запуска
нового потока.
Она принимает следующие аргументы:
\begin{itemize}
  \item \textit{pthread\_t* thread} --- идентификатор потока;
  \item \textit{const pthread\_attr\_t* attr} --- атрибуты потока;
  \item \textit{void *(*start\_routine)(void*)} --- указатель на функцию,
    предназначенную для выполнения в новом потоке;
  \item \textit{void* arg} --- аргумент, передаваемый в \textit{start\_routine}.
\end{itemize}

Данная функция возвращает нулевое значение в случае успеха
или код ошибки в противном случае.

Функция \textit{pthread\_exit()} предназначена для завершения вызывающего потока.
Она принимает параметр \textit{void* value\_ptr}, предназначенный для передачи
возвращаемого значения в поток, ожидающий завершения.
\pagebreak

Функция \textit{pthread\_join()} используется для ожидания вызывающим потоком
завершения работы указанного потока. Она принимает следующие аргументы:
\begin{itemize}
  \item \textit{pthread\_t thread} --- идентификатор потока,
    завершение которого мы собираемся ожидать;
  \item \textit{void** value\_ptr} --- двойной указатель на значение переменной
    \textit{value\_ptr}, переданное завершившимся потоком в
    соответствующий вызов \textit{pthread\_exit()}.
\end{itemize}

Функции \textit{pthread\_attr\_init()} и \textit{pthread\_attr\_destroy()}
предназначены для инициализации и удаления структуры атрибутов
потока соответственно. Структура атрибутов потока используется для
задания свойств создаваемого потока с помощью функций, описанных ниже.

С помощью функций \textit{pthread\_attr\_(get/set)detachstate()} можно указать,
будет ли поток создан в состоянии \textit{joinable} или \textit{detached}.
Разница между этими двумя типами потоков заключается в том,
что вызовы функций \textit{pthread\_join()} и \textit{pthread\_detach()}
в отношении \textit{detached} потока приводят к ошибке.
Функция \textit{pthread\_detach()} используется для перевода указанного \textit{joinable}
потока в состояние \textit{detached}.

Функции \textit{pthread\_attr\_*stack*()} предназначены для управления
параметрами стека запускаемого потока. Дело в том, что значения параметров стека
не являются стандартизованными, а поэтому могут различаться на различных ОС.
Каждая из этих функций принимает на вход структуру атрибутов потока и связанный параметр:
\begin{itemize}
  \item \textit{pthread\_attr\_(get/set)stacksize()} --- получение/установка размера стека
    создаваемого потока;
  \item \textit{pthread\_attr\_(get/set)stackaddr()} --- получение/установка стартового адреса
    стека создаваемого потока.
\end{itemize}

Поскольку все эти функции осуществляют доступ к структуре
атрибутов потока, их вызов должен осуществляться перед созданием потока.

Функция \textit{pthread\_self()} позволяет вызывающему потоку получить свой идентификатор,
a \textit{pthread\_equal()} позволяет сравнить пару идетификаторов потока.
Функция \textit{pthread\_once()} принимает пару аргументов:
\begin{itemize}
  \item структуру синхронизации \textit{once\_control};
  \item функцию \textit{init\_routine()}, подлежащую запуску в отдельном потоке.
\end{itemize}

Она устроена таким образом, что её многократные вызовы с одной и той же структурой синхронизации
приводят к тому, что её функция-аргумент вызывается в отдельном потоке лишь один (первый) раз.
На рисунке~\ref{lst:pthreads_basic} представлен простейший пример работы с POSIX-потоками.
\pagebreak

\lstinputlisting[
    caption=Работа с потоками POSIX,
    language={C},
    label=lst:pthreads_basic,
]{lst/pthreads_basic.c}

Здесь главный поток, выполняющий функцию \textit{main()},
создаёт, запускает \textit{NUM\_THREADS} потоков, выполняющих функцию \textit{task()},
и ожидает их завершения. Функция \textit{task()} выполняет циклический вывод
аргумента типа \textit{char} на консоль. На рисунке~\ref{lst:pthreads_basic_output}
приведен участок вывода данной программы.
\pagebreak

\lstinputlisting[
    caption=Пример работы программы~\ref{lst:pthreads_basic},
    label=lst:pthreads_basic_output,
]{lst/pthreads_basic_output.lst}

Нетрудно заметить, что результат вывода представляет собой случайную
последовательность символов \textit{'a'} и \textit{'b'}.
Это происходит вследствие того, что ОС выполняет переключение между
выполняемыми потоками в случайные моменты времени, вызывая тем самым прерывание
последовательности одинаковых символов, печатаемых данным потоком.
Для того, чтобы вывод символов осуществлялся в определенном неслучайном порядке,
необходимо выполнять синхронизацию потоков, рассматриваемую в следующем подразделе.

\subsection{Примитивы синхронизации}

\subsubsection{Мьютексы}

На практике часто возникает необходимость синхронизации работы набора потоков.
Более формально, необходимость синхронизации потоков возникает всякий раз,
когда ими осуществляется доступ к некоторому общему ресурсу,
при этом хотя бы один из них изменяет его состояние~\cite{Tanenbaum:2007:MOS:1410217}.
Подобная ситуация называется состоянием гонки (англ. \textit{race condition}).
Выполним краткий обзор средств синхронизации потоков, описанных в стандарте Pthreads.

Наиболее простым средством синхронизации является мьютекс (от англ. MUTual EXclusion),
предназначенный для взаимного исключения выполняющихся потоков.
Он предоставляет следующие гарантии:
\begin{itemize}
  \item выполнение различными потоками кода, защищенного мьютексом,
    выполняется последовательно;
  \item любые изменения состояния системы (значения переменных, файлов,
    буферов ввода/вывода и т.~д.),
    выполненные в коде, защищенном мьютексом, становятся доступны всем
    остальным потокам сразу после его освобождения.
\end{itemize}
\pagebreak

Рассмотрим работу мьютекса \( M \) на примере взаимодействия двух потоков,
\( P_1 \) и \( P_2 \), выполняющих защищенный им участок кода \( C \).
\begin{enumerate}
\item \( P_1 \) и \( P_2 \) готовы приступить к выполнению \( C \);
\item ОС переключается на \( P_1 \);
\item \( P_1 \) захватывает мьютекс \( M \) и начинает выполнение \( C \);
\item OC переключается на \( P_2 \);
\item \( P_2 \) пытается захватить \( M \) и блокируется ОС,
  поскольку мьютекс в данный момент уже захвачен \( P_1 \);
\item ОС переключается на \( P_1 \);
\item \( P_1 \) завершает выполнение \( C \) и освобождает \( M \),
  делая тем самым совершенные им изменения состояния видимыми для всех потоков;
\item ОС переключается на \( P_2 \) и разблокирует его, поскольку \( M \)
  в данный момент не захвачен;
\item \( P_2 \) захватывает \( M \), выполняет \( C \), а затем освобождает \( M \).
\end{enumerate}

Сформулируем список правил безопасного использования мьютексов:
\begin{itemize}
\item каждый мьютекс, захваченный потоком, должен им освобождаться;
\item захват и освобождение множества мьютексов должны осуществляться симметрично
  во избежание взаимоблокировок (\textit{deadlocks}).
\end{itemize}

К сожалению, выполнение данных правил, несмотря на простоту их формулировок,
на практике является делом весьма затруднительным.
Кроме этого, следует иметь в виду, что использование мьютексов,
особенно блокирование ими крупных участков кода, приводит к существенному
уменьшению скорости работы программы по следующим причинам:
\begin{itemize}
\item операции над мьютексами реализуются посредством системных вызовов,
  которые выполняются достаточно долго по определению;
\item запрещаются локальные оптимизации ассемблерных инструкций
  относительно захвата и освобождения мьютекса,
  что существенно сказывается на эффективности выполнения кода
  центральным процессором;
\item освобождение мьютекса приводит к инвалидации локальных кэшей
  (\textit{L1} и \textit{L2}) всех ядер процессора.
\end{itemize}

Рассмотрим программный интерфейс Pthreads для работы с мьютексами.
Мьютекс имеет тип \textit{pthread\_mutex\_t}, а структура его атрибутов ---
\textit{pthread\_mutexattr\_t}.
Её инициализация может производиться статически
(константа \textit{PTHREAD\_MUTEX\_INITIALIZER} или динамически
(функция \textit{pthread\_mutexattr\_init()}).
Для освобождения данной структуры используется функция
\textit{pthread\_mutexattr\_destroy()}.
С помощью данной структуры можно задавать тип мьютекса (обычный или рекурсивный).
Инициализация и освобождение мьютексов производится посредством
функций \textit{pthread\_mutex\_init()} и \textit{pthread\_mutex\_destroy()}
соответственно.

Для захвата мьютекса используются функции \textit{pthread\_mutex\_lock()}
и \textit{pthread\_mutex\_trylock()}. Отличие между этими двумя функциями
заключается в том, что вторая является неблокирующей --- если мьютекс на момент
её вызова уже заблокирован другим потоком, она возращает код ошибки в
вызывающий поток немедленно, а не блокирует его.
Функция \textit{pthread\_mutex\_unlock()} используется для освобождения
захваченного мьютекса.

Приведем пример использования мьютекса для для синхронизации вывода данных в консоль.
Пусть требуется, чтобы вывод различных потоков не перекрывался,
то есть чтобы отдельные символы, генерируемые этими потоками, не чередовались.
Для этого нам требуется модифицировать функцию \textit{task()} так, как показано на
рисунке~\ref{lst:pthreads_mutex}.

\lstinputlisting[
    caption=Использование мьютекса Pthreads,
    language={C},
    label=lst:pthreads_mutex,
]{lst/pthreads_mutex.c}

На рисунке~\ref{lst:pthreads_mutex_output} представлен пример вывода
модифицированной версии программы.

\lstinputlisting[
    caption=Пример работы программы~\ref{lst:pthreads_mutex},
    label=lst:pthreads_mutex_output,
]{lst/pthreads_mutex_output.lst}

Как видно из рисунка, теперь вывод программы является более упорядоченным ---
чередований различных символов больше не наблюдается.
Отметим, однако, что результат работы программы продолжает иметь случайный характер,
поскольку ОС не предоставляет гарантий того, что поток, освободивший мьютекс,
не сможет его захватить повторно, не уступая его своему конкуренту.
Для того, чтобы эффективно указать ОС желаемый порядок взаимодействия потоков,
наряду с мьютексами требуется использовать еще один примитив синхронизации ---
условную переменную.

\subsubsection{Условные переменные}

Условная переменная --- это примитив синхронизации,
который предназначен для указания порядка взаимодействия между потоками.
Условные переменные и мьютексы всегда используются совместно.
Рассмотрим простейший пример выполнения кода \( C \),
защищенного общим мьютексом \( M \) и условной переменной \( V \)
потоками \( P_1 \). Поток \( P_2 \) играет при этом управляющую роль.
Будем считать, что условная переменная в начале работы имеет значение ЛОЖЬ.
\begin{enumerate}
\item \( P_1 \) готов приступить к выполнению \( C \);
\item ОС переключается на \( P_1 \);
\item \( P_1 \) захватывает \( M \), проверяет значение \( V \), и,
  поскольку её значение равно ЛОЖЬ, освобождает мьютекс и блокируется операционной системой
  на \( V \);
\item ОС переключается на \( P_2 \);
\item \( P_2 \) захватывает \( M \), изменяет значение \( V \) на ИСТИНА;
\item ОС переключается на \( P_1 \);
\item \( P_1 \) остаётся в заблокированном состоянии, поскольку \( M \) не был освобожден \( P_2 \);
\item ОС переключается на \( P_2 \);
\item \( P_2 \) освобождает мьютекс;
\item ОС переключается на \( P_1 \);
\item \( P_1 \) захватывает \( M \), проверяет значение \( V \), и,
  поскольку её значение равно ИСТИНА, продолжает свою работу, а затем освобождает \( M \).
\end{enumerate}

Pthreads предоставляет следующие функции для работы с условными переменными:
\begin{itemize}
\item \textit{pthread\_cond\_init()} и \textit{pthread\_cond\_destroy()}
  для инициализации и уничтожения условной переменной соответственно;
\item \textit{pthread\_condattr\_init()} и \textit{pthread\_condattr\_destroy()}
  для инициализации и уничтожения атрибутов условной переменной соответственно;
\item \textit{pthread\_cond\_wait()} для проверки значения условной переменной;
\item \textit{pthread\_cond\_signal()} для разблокирования лишь одного потока,
  ожидающего изменения значения связанной переменной;
\item \textit{pthread\_cond\_broadcast()} используется для разблокирования всех потоков,
  ожидающих изменения значения связанной переменной.
\end{itemize}

Приведем пример использования условной переменной для для синхронизации вывода данных в консоль.
Пусть требуется, чтобы вывод различных потоков происходил по очереди,
при этом отдельные символы, генерируемые этими потоками, не чередовались.
Для этого требуется модифицировать функцию \textit{task()} так, как показано на
рисунке~\ref{lst:pthreads_condition}.

\lstinputlisting[
    caption=Использование условной переменной Pthreads,
    language={C},
    label=lst:pthreads_condition,
]{lst/pthreads_condition.c}

На рисунке~\ref{lst:pthreads_condition_output} представлен пример вывода
модифицированной версии программы.

\lstinputlisting[
    caption=Пример работы программы~\ref{lst:pthreads_condition},
    label=lst:pthreads_condition_output,
]{lst/pthreads_condition_output.lst}
