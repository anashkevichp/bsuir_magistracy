\section[Стандарт реализации потоков выполнения POSIX]{%
  СТАНДАРТ РЕАЛИЗАЦИИ ПОТОКОВ \\
  ВЫПОЛНЕНИЯ POSIX}

В прошлом программные интерфейсы управления потоками,
предоставляемые различными операционными системами, существенно различались.
Этот факт значительно усложнял написание кроссплатформенных программ.
В 1995 году был разработан и опубликован стандарт
программного интерфейса потоков IEEE POSIX 1003.c.
Он представляет собой набор связанных типов, функций и констант
языка C, позволяющих управлять жизненным циклом потоков
и выполнять их синхронизацию.
На данный момент программные интерфейсы упрвления потоками,
предоставляемые практически всеми операционными системами
на базе UNIX, являются POSIX-совместимыми~\cite{pthreads_programming}.

В соответствии со стандартом, программный интерфейс управления потоками
POSIX (Pthreads) описан в заголовочном файле \textit{<pthreads.h>}.
Следует отметить, что данный заголовочный файл не является частью
стандартной библиотеки языка C.

\subsection{Управление жизненным циклом потока}

Перечислим основные функции и типы данных стандарта Pthreads,
предназначенные для управления потоками.

Функция \textit{pthread\_create()} предназначена для создания и запуска
нового потока.
Она принимает следующие аргументы:
\begin{itemize}
  \item \textit{pthread\_t* thread} --- идентификатор потока;
  \item \textit{const pthread\_attr\_t* attr} --- атрибуты потока;
  \item \textit{void *(*start\_routine)(void*)} --- указатель на функцию,
    предназначенную для выполнения в новом потоке;
  \item \textit{void* arg} --- аргумент, передаваемый в \textit{start\_routine}.
\end{itemize}

Данная функция возвращает нулевое значение в случае успеха
или код ошибки в противном случае.

Функция \textit{pthread\_exit()} предназначена для завершения вызывающего потока.
Она принимает параметр \textit{void* value\_ptr}, предназначенный для передачи
возвращаемого значения в поток, ожидающий завершения.

Функция \textit{pthread\_join()} используется для ожидания вызывающим потоком
завершения работы указанного потока. Она принимает следующие аргументы:
\begin{itemize}
  \item \textit{pthread\_t thread} --- идентификатор потока,
    завершение которого мы собираемся ожидать;
  \item \textit{void** value\_ptr} --- двойной указатель на значение переменной
    \textit{value\_ptr}, переданное завершившимся потоком в
    соответствующий вызов \textit{pthread\_exit()}.
\end{itemize}

Функции \textit{pthread\_attr\_init()} и \textit{pthread\_attr\_destroy()}
предназначены для инициализации и удаления структуры атрибутов
потока соответственно. Структура атрибутов потока используется для
задания свойств создаваемого потока с помощью функций, описанных ниже.

С помощью функций \textit{pthread\_attr\_(get/set)detachstate()} можно указать,
будет ли поток создан в состоянии \textit{joinable} или \textit{detached}.
Разница между этими двумя типами потоков заключается в том,
что вызовы функций \textit{pthread\_join()} и \textit{pthread\_detach()}
в отношении \textit{detached} потока приводят к ошибке.
Функция \textit{pthread\_detach()} используется для перевода указанного \textit{joinable}
потока в состояние \textit{detached}.

Функции \textit{pthread\_attr\_*stack*()} предназначены для управления
параметрами стека запускаемого потока. Дело в том, что значения параметров стека
не являются стандартизованными, а поэтому могут различаться на различных ОС.
Каждая из этих функций принимает на вход структуру атрибутов потока и связанный параметр:
\begin{itemize}
  \item \textit{pthread\_attr\_(get/set)stacksize()} --- получение/установка размера стека
    создаваемого потока;
  \item \textit{pthread\_attr\_(get/set)stackaddr()} --- получение/установка стартового адреса
    стека создаваемого потока.
\end{itemize}

Поскольку все эти функции осуществляют доступ к структуре
атрибутов потока, их вызов должен осуществляться перед созданием потока.

Функция \textit{pthread\_self()} позволяет вызывающему потоку получить свой идентификатор,
a \textit{pthread\_equal()} позволяет сравнить пару идетификаторов потока.
Функция \textit{pthread\_once()} принимает пару аргументов:
\begin{itemize}
  \item структуру синхронизации \textit{once\_control};
  \item функцию \textit{init\_routine()}, подлежащую запуску в отдельном потоке.
\end{itemize}

Она устроена таким образом, что её многократные вызовы с одной и той же структурой синхронизации
приводят к тому, что её функция-аргумент вызывается в отдельном потоке лишь один (первый) раз.
На рисунке~\ref{lst:pthreads_basic} представлен простейший пример работы с POSIX-потоками.
\pagebreak

\lstinputlisting[
    caption=Пример работы с потоками POSIX,
    language={C},
    label=lst:pthreads_basic,
]{lst/pthreads_basic.c}

Здесь главный поток, выполняющий функцию \textit{main()},
создаёт, запускает \textit{NUM\_THREADS} потоков, выполняющих функцию \textit{task()},
и ожидает их завершения. Функция \textit{task()} выполняет циклический вывод
аргумента типа \textit{char} на консоль. На рисунке~\ref{lst:pthreads_basic_output}
приведен участок вывода данной программы.
\pagebreak

\lstinputlisting[
    basicstyle=\scriptsize\ttfamily,
    caption=Пример несинхронизированного вывода,
    label=lst:pthreads_basic_output,
]{lst/pthreads_basic_output.lst}

Нетрудно заметить, что результат вывода представляет собой случайную
последовательность символов \textit{'a'} и \textit{'b'}.
Это происходит вследствие того, что ОС выполняет переключение между
выполняемыми потоками в случайные моменты времени, вызывая тем самым прерывание
последовательности одинаковых символов, печатаемых данным потоком.
Для того, чтобы вывод символов осуществлялся в определенном неслучайном порядке,
необходимо выполнять синхронизацию потоков, рассматриваемую в следующем подразделе.

\subsection{Примитивы синхронизации}

\subsubsection{Мьютексы}

На практике часто возникает необходимость синхронизации работы набора потоков.
Более формально, необходимость синхронизации потоков возникает всякий раз,
когда ими осуществляется доступ к некоторому общему ресурсу,
при этом хотя бы один из них изменяет его состояние~\cite{Tanenbaum:2007:MOS:1410217}.
Подобная ситуация называется состоянием гонки (англ. \textit{race condition}).
Выполним краткий обзор средств синхронизации потоков, описанных в стандарте Pthreads.

Наиболее простым средством синхронизации является мьютекс (от англ. MUTual EXclusion),
предназначенный для взаимного исключения выполняющихся потоков.
Он предоставляет следующие гарантии:
\begin{itemize}
  \item выполнение различными потоками кода, защищенного мьютексом,
    выполняется последовательно;
  \item любые изменения состояния системы (значения переменных, файлов,
    буферов ввода/вывода и т.~д.),
    выполненные в коде, защищенном мьютексом, становятся доступны всем
    остальным потокам сразу после его освобождения.
\end{itemize}

Рассмотрим работу мьютекса \( M \) на примере взаимодействия двух потоков,
\( P_1 \) и \( P_2 \), выполняющих защищенный им участок кода \( C \).
\begin{enumerate}
\item \( P_1 \) и \( P_2 \) готовы приступить к выполнению \( C \);
\item ОС переключается на \( P_1 \);
\item \( P_1 \) захватывает мьютекс \( M \) и начинает выполнение \( C \);
\item OC переключается на \( P_2 \);
\item \( P_2 \) пытается захватить \( M \) и блокируется ОС,
  поскольку мьютекс в данный момент уже захвачен \( P_1 \);
\item ОС переключается на \( P_1 \);
\item \( P_1 \) завершает выполнение \( C \) и освобождает \( M \),
  делая тем самым совершенные им изменения состояния видимыми для всех потоков;
\item ОС переключается на \( P_2 \) и разблокирует его, поскольку \( M \)
  в данный момент не захвачен;
\item \( P_2 \) захватывает \( M \), выполняет \( C \), а затем освобождает \( M \).
\end{enumerate}

Сформулируем список правил безопасного использования мьютексов:
\begin{itemize}
\item каждый мьютекс, захваченный потоком, должен им освобождаться;
\item захват и освобождение множества мьютексов должны осуществляться симметрично
  во избежание взаимоблокировок (\textit{deadlocks}).
\end{itemize}

К сожалению, выполнение данных правил, несмотря на простоту их формулировок,
на практике является делом весьма затруднительным.
Кроме этого, следует иметь в виду, что использование мьютексов,
особенно блокирование ими крупных участков кода, приводит к существенному
уменьшению скорости работы программы по следующим причинам:
\begin{itemize}
\item операции над мьютексами реализуются посредством системных вызовов,
  которые выполняются достаточно долго по определению;
\item запрещаются локальные оптимизации ассемблерных инструкций
  относительно захвата и освобождения мьютекса,
  что существенно сказывается на эффективности выполнения кода
  центральным процессором;
\item освобождение мьютекса приводит к инвалидации локальных кэшей
  (\textit{L1} и \textit{L2}) всех ядер процессора.
\end{itemize}

Рассмотрим программный интерфейс Pthreads для работы с мьютексами.
Мьютекс имеет тип \textit{pthread\_mutex\_t}, а структура его атрибутов ---
\textit{pthread\_mutexattr\_t}.
Её инициализация может производиться статически
(константа \textit{PTHREAD\_MUTEX\_INITIALIZER} или динамически
(функция \textit{pthread\_mutexattr\_init()}).
Для освобождения данной структуры используется функция
\textit{pthread\_mutexattr\_destroy()}.
С помощью данной структуры можно задавать тип мьютекса (обычный или рекурсивный).
Инициализация и освобождение мьютексов производится посредством
функций \textit{pthread\_mutex\_init()} и \textit{pthread\_mutex\_destroy()}
соответственно.

Для захвата мьютекса используются функции \textit{pthread\_mutex\_lock()}
и \textit{pthread\_mutex\_trylock()}. Отличие между этими двумя функциями
заключается в том, что вторая является неблокирующей --- если мьютекс на момент
её вызова уже заблокирован другим потоком, она возращает код ошибки в
вызывающий поток немедленно, а не блокирует его.
Функция \textit{pthread\_mutex\_unlock()} используется для освобождения
захваченного мьютекса.


% Здесь в функции \textit{main()} выполняется создание потока,
% выполняющего функцию \textit{printHello()} с использованием
% аргумента, представляющего собой структуру \textit{thread\_data}.
% Следует отметить, что в тех случаях, когда исполнение функции
% потока заканчивается, выход из потока выполняется автоматически.



% *** Управление жизненным циклом потока
% *** Примитивы синхронизации