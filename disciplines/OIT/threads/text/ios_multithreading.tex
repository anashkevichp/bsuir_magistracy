\section[Механизмы реализации многопоточности в среде iOS]
{МЕХАНИЗМЫ РЕАЛИЗАЦИИ \\ МНОГОПОТОЧНОСТИ В СРЕДЕ IOS}

\subsection{Использование POSIX Thread API}

\textit{POSIX (англ. portable operation system interface)} --- перечень стандартов,
описываюших интерфейсы взаимодействия между операционной системой и прикладной
программой. Стандарт POSIX реализован на языке C, реализация входит в библиотеку языка.
Так как язык Objective-C представлят собой
надстройку над языком C, то имеется возможность использовать все стандартные
инструменты языка C, в том числе и механизмы управления памяти POSIX.

Интерфейс по работе с потоками POSIX относительно прост в использовании, предоставляет
достаточную гибкость для настройки потоков, а также делает код программы
адаптированным к перекосу на другие платформы.

Основные функции работы с POSIX Thread API приведены на рисунке~\ref{lst:posix_functions}.

\lstinputlisting[
    caption=Основные функции работы с POSIX Thread API,
    language={C},
    label=lst:posix_functions,
]{lst/posix_functions.txt}


\subsection{Использование Grand Central Dispatch}

\textit{GCD (Grand Central Dispatch)} --- механизм создания и управление потоками
в среде платформ компании Apple (iOS, macOS и др.), который позволяет разработчику
сосредоточиться на задачах, которые необходимо выполнить, а не на управлении потоками.
В GCD, можно определить задачу, которую требуется выполнить, и добавить ее в
рабочую очередь, которая занимается планированием и установкой задачи
на соответствующий поток.
Рабочая очередь учитывает количество доступных ядер и потоковую нагрузку для
выполнения задач более эффективно, чем можно было бы это сделать самостоятельно.

Например, пусть требуется выполнить какую-либо операцию в фоновом режиме. Для
этого необходимо выполнить захват одной из глобальных очередей приложения так,
как это показано на рисунке~\ref{lst:dispatch_get_global_queue}.
\lstinputlisting[
    caption=Захват одной из глобальных очередей приложения,
    language={C},
    label=lst:dispatch_get_global_queue,
]{lst/dispatch_get_global_queue.txt}

Для возврата в главный поток существует конструкция, проиллюстрированная
на рисунке~\ref{lst:dispatch_get_main_queue}.
\lstinputlisting[
    caption=Захват одной из глобальных очередей приложения,
    language={C},
    label=lst:dispatch_get_main_queue,
]{lst/dispatch_get_main_queue.txt}

Для создания новой очереди можно использовать функцию \textit{dispatch\_queue\_create(identifier)},
после завершения работы с очередью имеет смысл вызывать функцию \textit{dispatch\_release(<queue>)}.
Впрочем, компания Apple настоятельно рекомендует использовать
существующие на этапе выполнения программы \textit{serial} и \textit{concurrent} очереди.

\subsection{Использование NSOperation и NSOperationQueue}

NSOperation и NSOperationQueue построенные поверх GCD. Стоит заметить что,
Apple рекомендует использовать абстракцию высшего уровня, и затем опуститься
к нижним уровням, когда измерения показывают, что они необходимы.

Вот краткое сравнение, которое, поможет решить, когда и где использовать
GCD или NSOperation:
\begin{itemize}
  \item GCD это легковесный способ представление единиц работы, которые будут
    выполняться одновременно. Ненужно вносить в список эти единицы работы;
    система сама позаботится об этом. Добавление зависимости среди блоков может
    быть не легким заданием. Отмена или приостановка блока создает
    дополнительную работу.
  \item NSOperation добавляет небольшие дополнительные издержки по сравнению с GCD,
    но имеется возможность добавить зависимость для различных операций,
    повторно использовать, отменить или приостановить их.
\end{itemize}


\subsection{Использование NSThread}

Есть два способа создания потока c использованием класса NSThread:
\begin{itemize}
  \item использование метода класса detachNewThreadSelector:toTarget:withObject:,
    чтобы породить новый поток.
  \item создание нового объекта NSThread и вызов его метода start.
    (Поддерживается только в iOS и Mac OS X 10.5 и выше.)
\end{itemize}

Поскольку detachNewThreadSelector:toTarget:withObject: метод поддерживается
всеми версиями Mac OS X, он часто встречается в существующих Cocoa приложениях,
использующих потоки.

Простой способ инициализации NSThread объекта в Mac OS X 10.5 и более поздних
является использование метода initWithTarget:selector:object:. Этот метод
имеет точно такую ​​же информацию, как метод detachNewThreadSelector:toTarget:withObject:
и использует его для инициализации нового экземпляра NSThread. Однако он не
запускает поток. Чтобы запустить поток, необходимо вызвать метод start
объекта потока в явном виде, как показано на рисунке~\ref{lst:nsthread}.
\lstinputlisting[
    caption=Запуск потока для выполнения метода,
    language={C},
    label=lst:nsthread,
]{lst/nsthread.txt}


\subsection{Использование NSRunLoop}

Для сосздания нового потока в среде программирования под iOS есть возможность
создания так называемого цикла выполнения (NSRunLoop), который будет следить за какими-либо
событиями.

NSRunLoop --- достаточно старая технология, появившаяся еще с iOS 2.0,
позволяющая оптимизировать использование вычислительных ресурсов в рамках одного потока.
Тем не менее, многие классы фреймворка Cocoa Touch все ещё используют NSRunLoop,
и в некоторых случаях требуется запустить NSRunLoop на другом, не главном, потоке.

Для того, чтобы запустить NSRunLoop на другом потоке так, чтобы он оставался
в работающем состоянии, нужно добавить на него до его запуска хотя бы один
входящий источник (input source), в противном случае, NSRunLoop сразу завершится
и его нельзя будет использовать. Таким источником, может быть, например, NSTimer,
который будет повторяться.

На рисунке ~\ref{lst:nsrunloop} приведен пример прослушивания входного потока данных
с использованием NSRunLoop.
\lstinputlisting[
    caption=Пример прослушивания входного потока данных,
    language={C},
    label=lst:nsrunloop,
]{lst/nsrunloop.txt}

Отдельно стоит заметить, что Apple рекомендует использовать абстракцию
высшего уровня для управления многопоточностью в приложениях iOS,
а затем опуститься к нижним уровням, когда измерения показывают,
что они необходимы.

\pagebreak
