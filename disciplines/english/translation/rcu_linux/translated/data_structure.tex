\subsection{Структуры данных Tree RCU} \label{sec:data_structure}

\begin{figure}[tbp]
\centering
\includegraphics[scale=0.2]{tree_rcu_hierarchy.pdf}
\caption{Иерархия Tree RCU}
\label{fig:tree_rcu_hierarchy}
\end{figure}

Глобальное состояние RCU записывается в структуру \co{rcu_state},
представляющую собой дерево структур \co{rcu_node} с арностью, равной 64
(32 на 32-битных системах). Каждый терминальный узел данного дерева
может иметь ссылки на максимум 64 (32 на 32-битных системах) структуры
\co{rcu_data} каждая из которых соответствует отдельному ядру процессора,
как показано на рисунке~\ref{fig:tree_rcu_hierarchy}.
Каждая структура \co{rcu_data} ведет учет устойчивых состояний своего ядра,
а \co{rcu_node}-дерево используется сначала для распространения информации
об этих состояниях в направлении корня,
а затем --- для распространия информации о grace-периодах в направлении листьев.
Информация об устойчивых состояниях передается на родительский уровень
в тот момент времени, когда каждый узел-потомок каждого поддерева данного уровня
уже передал её в корень этого поддерева.
Эта схема передачи информации позволяет существенно сократить частоту использования
блокировок на верхних уровнях дерева.
Например, рассмотрим стандартное \co{rcu_node} дерево для системы с
4{,}096 вычислительными ядрами, имеющее 256 терминальных узлов,
4 внутренних узлов и один корневой узел. В течение данного grace-периода,
каждое ядро процессора сообщит информацию о своем устойчивом состоянии в
соответствующий терминальный узел, но при этом каждому терминальному узлу
будет соответствовать всего 16 соперничающих ядер.
Всего 256 ядер будут пытаться сообщить свои устойчивые состояния внутренним узлам,
при этом всего информация 64 ядер дойдет до каждого из четырех внутренних узов.
Наконец, информация всего четырех ядер может дойти до корневого узла,
что приводит к очень низкой частоте его блокирования.
Это позволяет использовать данную структуру на очень больших системах.
В частности, существующая реализация RCU ядра Linux поддерживает
четырехуровневые деревья, что позволяет использовать до
$64^4 = 16{,}777{,}216$ ядрами на 64-битных системах.\footnote{
  В настоящее время четырехуровневые деревья используются при нагрузочном тестировании,
  а трехуровневые находят свое применение на промышленных 4096-ядерных системах.}

\subsubsection{Структура \co{rcu_state}}

\begin{figure}[tbp]
\centering
\includegraphics[scale=0.9]{rcu_node_array.pdf}
\caption{Представление дерева структур \co{rcu_node} в виде массива}
\label{fig:rcu_node_array}
\end{figure}

Каждая реализация RCU имеет свою собственную структуру \co{rcu_state}.
Структура \co{rcu_state} включает в себя массив структур \co{rcu_node},
логически организованных в виде дерева \co{struct rcu_node node[NUM_RCU_NODES]},
со структурами \co{rcu_data}, присоединенными к его терминальным узлам.
Таким образом, обход этого дерева в ширину сводится к линейному проходу по массиву.
Еще один массив структур \co{rcu_node}, \co{*level[NUM_RCU_LVLS]},
используется для указания на самый левый узел каждого уровня дерева,
как показано на рисунке~\ref{fig:rcu_node_array}.

Структура \co{rcu_state} использует поля \co{->gpnum} и \co{->completed}
типа \co{unsigned long} для учета grace-периодов.
Поле \co{->gpnum} используется для отслеживания начала последнего grace-периода,
в то время как \co{->completed} отслеживает окончание последнего grace-периода.
Если значения данных полей одинаковы, то RCU находится в состоянии по умолчанию.
Если же значение \co{gpnum} больше, чем \co{completed}, то RCU находится в состоянии
grace-периода. Все прочие комбинации являюется недопустимыми.

\subsubsection{Структура \co{rcu_node}}
\label{sec:rcu_node}
Дерево структур \co{rcu_node} регистрирует и распространяет
информацию об устойчивых состояниях от терминальных узлов к корневому,
а также распространяет информацию о grace-периодах в обратном направлении.
Структура \co{rcu_node} использует спин-блокировку \co{->lock} для защиты
своих полей. Поле \co{->parent} содержит указатель на струтуру-родителя,
при этом значение данного поля у корневого узла равно \co{NULL}.
Значение поля \co{->level} равно номеру уровня,
на котором находится данный узел в дереве,
считая уровень корневого узла нулевыми.
Поле \co{->grpmask} описывает номер бита данного узла в значении поля
\co{->qsmask} узла-родителя.
Поля \co{->grplo} и \co{->grphi} соответствуют наименьшему и наибольшему
порядковому номеру вычислительного ядра, учитываемого данной структурой.

Поле \co{->qsmask} указывает, какие из узлов-потомков еще не сообщили
о своих устойчивых состояниях на данный момент времени.
Как и в случае с \co{rcu_state}, структура \co{rcu_node} имеет поля
\co{->completed} и \co{->gpnum}, имеющие такие же значения, как и у родительской
структуры \co{rcu_state}, за исключением начала и конца каждого
grace-периода, когда данные значения копируются из корневого узла.
Значения этих полей могут быть равны друг другу, либо отличаться на единицу.

\subsubsection{Структура \co{rcu_data}} \label{sec:rcu_data}
Структурв \co{rcu_data} используется для учета устойчивых состояний и
вызова callback'ов связанного вычислительного ядра.
Поскольку доступ к данной структуре только осуществляется посредством
связанного вычислительного ядра, нет необходимости выполнять синхронизацию.
Как и в случае со структурой \co{rcu_state}, различные реализации RCU поддерживают
различные виды структур \co{rcu_data}.
Поле \co{->cpu} указывает на связанное вычислительное ядро,
\co{->rsp} --- на связанную структуру \co{rcu_state},
а \co{->mynode} ссылается на соответсвующую терминальную структуру \co{rcu_node}.
Значение поля \co{->grpmask} указывает на позицию структуры \co{rcu_data}
в битовом поле \co{->qsmask} связанной структуры \co{rcu_node}.

Структура \co{rcu_data} содержит поле \co{->qs_pending}, указывающее,
что RCU ожидает получения устойчивого состояния от связанного ядра,
и поле \co{->passed_quiesce}, указывающее на то, что данное ядро уже
прошло через устойчивое состояние.
Кроме этого, данная структура имеет поля \co{->gpnum} и \co{->completed},
значения которых могут отставать от соответсвующих им полей структур
\co{rcu_state} и \co{rcu_node} в режиме простоя ядер процессора.
С другой стороны, если ядра процессора являются заблокированными,
их значения могут оставать лишь на один grace-период от соответсвующих значений
полей структуры \co{rcu_node}.

Поля \co{->gpnum} и \co{->completed} структуры \co{rcu_state} содержат наиболее
актуальные значения и используются для обновления соответствующих полей родительских
структур \co{rcu_node}, что позволяет сравнивать значения данных полей со значениями
этих же полей структур \co{rcu_node} для фиксации факта начала очередного grace-периода.
Эта схема позволяет вычислительным ядрам обнаруживать границы grace-периодов
без использования блокировок.
Структруа \co{rcu_data} управляет RCU callback'ами с помощью
структуры данных, известной как четырехсегментный
список~\cite{LaiJiangshan2008NewClassicAlgorithm}.

\input{callback.tex}
