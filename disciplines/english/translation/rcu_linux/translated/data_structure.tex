\subsection{Структуры данных Tree RCU} \label{sec:data_structure}
% In Section~\ref{sec:rcu_softirq}, we discuss how RCU's softirq handlers walk up the
% tree hierarchy of the \co{rcu_node} data structure. In ths section, we explain
% in detail how this data structure is implemented in \co{kernel/rcu/tree.h} and used
% in Tree RCU.

\begin{figure}[tbp]
\centering
\includegraphics[scale=0.2]{tree_rcu_hierarchy.pdf}
\caption{Иерархия Tree RCU}
\label{fig:tree_rcu_hierarchy}
\end{figure}

Глобальное состояние RCU записывается в структуру \co{rcu_state},
представляющую собой дерево структур \co{rcu_node} с арностью, равной 64
(32 на 32-битных системах). Каждый терминальный узел данного дерева
может иметь ссылки на максимум 64 (32 на 32-битных системах) структуры
RCU's global state is recorded in the \co{rcu_state} structure, which consists of
a tree of \co{rcu_node} structures with a child count of up to 64
(32 in a 32-bit system). Every leaf node can have at most 64 \co{rcu_data},
каждая из которых представляет собой отдельное ядро процессока,
как показано на рисунке~\ref{fig:tree_rcu_hierarchy}.
%
Каждая структура \co{rcu_data} веде учет устойчивых состояний своего ядра,
а \co{rcu_node}-дерево сначала используется для распространения информации
об этих состояниях сначала в направлении корня,
затем --- для распространия информации о grace-периодах в направлении листьев.
%
Информация об устойчивых состояниях передается на родительский уровень
в тот момент времени, когда каждый узел-потомок каждого поддерева данного уровня
уже передал её в корень этого поддерева.
Эта сзема передачи информации позволяет существенно сократить частоту использования
блокировок на верхних уровнях дерева.
%
% Lihao: include this in PhD thesis and the technical report
Например, рассмотрим стандартное \co{rcu_node} дерево для системы с
4{,}096 вычислительными ядрами, имеющее 256 терминальных узлов,
4 внутренних узлов и один корневой узел. В течение данного grace-периода,
каждое ядро сообщит информацию о своем устойчивом состоянии в
соответствующий терминальный узел, но при этом каждому терминальному узлу
будет соответствовать всего 16 соперничающих ядер.
Всего 256 ядер будут пытаться сообщить свои устойчивые состояния внутренним узлам,
при этом всего информация 64 ядер дойдет до каждого из четырех внутренних узов.
Наконец, информация всего четырех ядер может дойти до корневого узла,
что сказывается на его очень низкой частоте блокирования.
Это позволяет использовать данную структуру на очень больших системах.
В частности, актуальная реализация RCU ядра Linux поддерживает
четырехуровневые деревья, что позволяет использовать до
$64^4 = 16{,}777{,}216$ ядрами на 64-битных системах.\footnote{
  В настоящее время четырехуровневые деревья используются при нагрузочном тестировании,
  а трехуровневые находят свое применение на промышленных 4096-ядерных системах.}

\subsubsection{\co{rcu_state} Structure}

\begin{figure}[tbp]
\centering
\includegraphics[scale=0.9]{rcu_node_array.pdf}
\caption{Представление дерева структур \co{rcu_node} в виде массива}
\label{fig:rcu_node_array}
\end{figure}

Кажжый реализация RCU имеет свою собственную структуру \co{rcu_state}.
Структура \co{rcu_state} включает в себя массив структур \co{rcu_node},
логически организованных в виде дерева
\co{struct rcu_node node[NUM_RCU_NODES]},
со структурами \co{rcu_data}, присоединенными к его терминальным узлам.
Таким образом, обход этого дерева в ширину сводится линейному проходу по массиву.
Еще один массив структур \co{rcu_node}, \co{*level[NUM_RCU_LVLS]},
используется для указания на самый левый узел каждого уровня дерева,
как показано на рисунке~\ref{fig:rcu_node_array}.

Структура \co{rcu_state} использует поля \co{->gpnum} и \co{->completed}
типа \co{unsigned long} для учета grace-периодов.
Поле \co{->gpnum} используется для отслеживания начала последнего grace-периода,
в то время как \co{->completed} отслеживает окончание последнего grace-периода.
Если значения данных полей одинаковы, то соответствующий RCU находится в состоянии
по умолчанию. Если же значение \co{gpnum} больше, чем \co{completed},
то RCU находится в состоянии grace-периода.
Все прочие комбинации недопустимы.

\subsubsection{\co{rcu_node} Structure}
\label{sec:rcu_node}
Дерево структур \co{rcu_node} регистрирует и распространяет
информацию об устойчивых состояниях от терминальных узлов к корневому,
а также распространяет информацию о grace-периодах в обратном направлении.
%
Структура \co{rcu_node} использует спин-блокировку \co{->lock} для защиты
своих полей. Поле \co{->parent} содержит указатель на струтуру-родителя,
при этом значение данного поля у корневого узла равно \co{NULL}.
Значение поля \co{->level} соответствует, на котором находится данный
узел в дереве, при этом уровень корневого узла равен нулю.
Поле \co{->grpmask} описывает номер бита данного узла в значении поля
\co{->qsmask} узла-родителя.
Поля \co{->grplo} и \co{->grphi} соответствуют наименьшему и наибольшему
порядковому номеру вычислительного ядра, учитываемого данной структурой.

Поле \co{->qsmask} указывает, какие из узлов-потомков еще не сообщили
о своих устойчивых состояниях на данный момент времени.
%
Как и в случае с \co{rcu_state}, структура \co{rcu_node} имеет поля
\co{->completed} и \co{->gpnum}, имеющие такие же значения, как и у родительской
структуры \co{rcu_state}, за исключением начала и конца каждого
grace-периода, когда данные значения копируются из корневого узла.
Значения этих полей могут быть равны друг другу, либо отличаться на единицу.

%\comment{Lihao: comment out the following preemptible RCU contents if we need space.}
%In a preemptible kernel, tasks can be preempted during RCU read-side
%critical sections.
%When an RCU read-side critical section is preempted,
%the preempted task's \co{task_struct} is enqueued onto the \co{->blkd_tasks}
%list in the leaf \co{rcu_node} structure covering the task's CPU.
%That task will remove itself once it reaches the RCU read-side critical
%section's outermost \co{rcu_read_unlock()},
%%
%When the \co{->gp_tasks} pointer is non-\co{NULL}, it references the first
%task blocking the current grace period.
%When a task referenced by \co{gp_tasks} points is removed
%from \co{blkd_tasks}, the pointer will be advanced to the next task on the list,
%or is set to \co{NULL} if there are no more tasks.
%Note that
%tasks blocking the current grace period are queued in the reverse time order.
%Thus, if a task is blocking a grace period,
%all subsequent tasks on the list are blocking the same grace period.
% Lihao: how the tasks are dequeued is described in quiescent state detection
% Lihao: we ignore expedited grace period for now
% Lihao: we don't model priority boosting

\subsubsection{Структура \co{rcu_data}} \label{sec:rcu_data}
Структурв \co{rcu_data} используется для учета устойчивых состояний и
вызова callback'ов связанного вычислительного ядра.
Поскольку доступ к данной структуре осуществляется посредством
связанного вычислительного ядра, нет необходимости выполнять синхронизацию.
Как и в случае со структурой \co{rcu_state}, различные реализации RCU поддерживают
различные виды структур \co{rcu_data}.
% For instance, RCU-sched's
%\co{rcu_sched_state}, RCU-bh's \co{rcu_bh_state} and RCU-preempt's
%\co{rcu_state_p} structures have \co{rcu_data} structures \co{rcu_sched_data},
%\co{rcu_bh_data}, and \co{rcu_data_p}, respectively.
%
Поле \co{->cpu} указывает на связанное вычислительное ядро,
\co{->rsp} --- на связанную структуру \co{rcu_state},
а \co{->mynode} ссылается на соответсвующую терминальную структуру \co{rcu_node}.
Значение поля \co{->grpmask} указывает на позицию структуры \co{rcu_data}
в битовом поле \co{->qsmask} связанной структуры \co{rcu_node}.

Структура \co{rcu_data} содержит поле \co{->qs_pending}, указывающее,
что RCU ожидает получения устойчивого состояния от связанного ядра,
и поле \co{->passed_quiesce}, указывающее на то, что данное ядро уже
прошло через устойчивое состояние.
%
Кроме этого, данная структура также имеет поля \co{->gpnum} и \co{->completed},
значения которых могут отставать от соответсвующих им полей структур
\co{rcu_state} и \co{rcu_node} в нормальном режиме работы ядер процессора.
С другой стороны, если ядра процессора являются заблокированными,
их значения могут оставать на один grace-период от соответсвующих значений
полей структуры \co{rcu_node}.

Поля \co{->gpnum} и \co{->completed} структуры \co{rcu_state} содержат наиболее
актуальные значения и используются для обновления соответствующих полей родительских
структур \co{rcu_node}, что позволяет сравнивать значения данных полей со значениями
этих же полей структур \co{rcu_node} для фиксации факта начала нового grace-периода.
Эта схема позволяет вычислительным ядрам обнаруживать границы grace-периодов
без использования блокировок.
%
Структруа \co{rcu_data} управляет RCU callback'ами с помощью
структуры данных, известной как четырехсегментный
список~\cite{LaiJiangshan2008NewClassicAlgorithm}.

% Lihao: but we need to carefully manage the numbers of each node as the consequences of
% using a quiescent state in a wrong grace period can be quite serious.
% Paul: Indeed!  And the grace-period initialization (rcu_gp_init()) and
% cleanup (rcu_gp_cleanup()) code first updates the rcu_state structure and
% then the rcu_node structures in breadth-first order to avoid such
% consequences.  In addition, cleanup propagates ->completed completely
% and only then is ->gpnum propagated for the new grace period.  Attempting
% to "optimize" this to propagate ->completed and ->gpnum changes in one
% pass results in nasty race conditions caused by different CPUs believing
% that different active grace periods are in effect.  Very low probability,
% but -very- nasty.

% Lihao: we don't model dyntick-idle handling
% Lihao: include this in the technical report
\input{callback.tex}
