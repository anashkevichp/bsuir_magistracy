\section{Введение}
Ядро операционной системы Linux широко используется во множестве
вычислительных платформ, включая сервера, встроенные системы,
бытовую технику и мобильные устройства (смартфоны).
В течение последних 25 лет в ядре Linux было реализовано
множество технологий, одной из которых является
Read-Copy Update (RCU)~\cite{McKenneyRCU98}.

RCU --- это механизм синхронизации, который может использоваться
взамен блокировок чтения-записи в случаях,
когда число запросов на чтение значительно
больше числа запросов на запись.
Он позволяет выполнять нетребовательные к ресурсам запросы на
чтение данных вместе с запросами на их изменение.
Качественные реализации RCU для многоядерных систем
должны обладать такими качествами, как отличная масштабируемость,
высокая пропускная способность, низкие задержки, умеренный расход памяти,
низкое энергопотребление и поддерживать <<hotplug>> операции процессора.
Чтобы удовлетворять этим требованиям,
такая реализация должна избегать кэш-промахов,
избыточного использования блокировок, общих переменных,
а также атомарных <<read-modify-write>> и <<memory-barrier>> инструкций.
Наконец, реализация должна поддерживать все многообразие
целевых платформ и сценариев использования Linux~\cite{McKenneyOSR08}.

В настоящее время RCU широко используется в сетевой, файловой подсистемах
ядра Linux, а также в подсистеме работы с
устройствами~\cite{McKenneyOSR08,McKenneyRCUsageReport13}.
%\url{http://www2.rdrop.com/~paulmck/RCU/linuxusage/linux-4.3.sum}}
На данный момент в мире насчитывается более 75 миллионов
Linux-серверов и 1.4 миллирда мобильных устройств под управлением ОС Android.
Это приводит к тому, что даже малейшая ошибка в исходном коде
реализации будет проявлятся на целевый устройствах недопустимо часто.
В связи с этим, строгая валидация сложных сценариев поведения RCU получает
критическую важность. Поскольку исчерпывающее тестирование данного
механизма невозможно из-за экпоненциального роста числа сценариев тестирования,
имеет смысл использовать некоторый метод формальной верификации.

Основные усилия, связанные с верификацией многопоточного программного
обеспечения, основаны на тестировании, но, к сожалению,
на данный момент не существует эффективной методики тестирования такого ПО,
способной проверить все возможные сценарии работы.
Более того, некоторые ошибки, обнаруживаемые в ходе тестирования,
могут быть трудными для повторного воспроизведения, отладки и исправления.
Многопоточная сущность RCU и огромное пространство возможных сценариев
тестирования наводят на мысль об необходимости использовании
методов формальной верификации,
в частности, верификации моделей~\cite{BurchInfComput92}.

Следует отметить, что подобные методы уже применялись ранее
для верификации некоторых частей дизайна RCU, например
Tiny RCU~\cite{VerificationChallenges}, userspace RCU~\cite{DesnoyersOSR13},
sysidle~\cite{VerificationChallenges} и взаимодействия между
dyntick-idle и немаскируемыми прерываениями (NMIs)~\cite{ValDyntickNMI}.
Но эти попытки были направлены либо на верификацию примитивных реализаций
RCU для одноядерных систем (Tiny RCU), либо использовали специализированные
языки описания моделей, такие, как Promela~\cite{HolzmannTSE97SPIN}.
Несмотря на то, что данные языки имеют ряд преимуществ,
основных недостатком их использования в контексте верификации ядра Linux
является сложность ручной трансляции исходного кода.
Некоторые исследователи предлагают использовать аппарат формальной логики для
верификации простых реализаций RCU~\cite{YangESOP13RCU,DreyerPLDI15RCU}.
Несмотря на то, что данный подход является весьма интересным,
он требует большего количества работы, нежели трансляция исходного кода.

Более того, цикл разработки ядра Linux составляет около 60 дней,
и в течение каждого из них вносятся правки в механизм RCU.
В связи с этим всякий ручной труд по верификации должен будет
повторяться шесть раз в год, чтобы формальные модели верификации RCU
оставались актуальными.
Из этого следует, что для того, чтобы процесс формальной верификации
RCU мог быть включен в набор регрессионных тестов, используемые в нем методы
должны быть автоматизируемыми и масштабируемыми.
В этой статье рассматривается процесс построения модели верификации напрямую из
исходного кода реализации RCU в Linux и использование
C~Bounded Model Checker (CBMC)~\cite{KroeningTACAS04CBMC}
для проверки ее инвариантных свойств.
По нашим сведениям, это первая попытка автоматизированной верификации
существенной части исходного кода RCU, являющаяся важным шагом на пути
интеграции процедуры формальной верификации в набор регрессионных
тестов ядра Linux.
