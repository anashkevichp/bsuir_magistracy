\section{Введение}
Ядро операционной системы Linux широко используется во множестве
вычислительных платформ, включая сервера, встроенные системы,
бытовую технику и мобильные устройства (смартфоны).
В течение последних 25 лет в ядре Linux было реализовано
множество технологий, одной из которых является
Read-Copy Update (RCU)~\cite{McKenneyRCU98}.

RCU --- это механизм синхронизации, который может исопльзоваться
взамен блокировок чтения-записи в тех случаях,
когда число запросов на чтение значительно больше.
Он позволяет выполнять нетребовательные к ресурсам запросы на
чтение данных вместе с запросами на их изменение.
Качественные реализации RCU для многоядерных систем
должны обладать такими качествами, как отличная масштабируемость,
высокая пропускная способность, низкие задержки, умеренный расход памяти,
низкое энергопотребление и поддерживать <<hotplug>> операции процессора.
В связи с этим реализация должна избегать кэш-промахов,
избыточного использования блокировок, общих переменных,
а также атомарных <<read-modify-write>> и <<memory-barrier>> инструкций.
Наконец, реализация должна поддерживать все многообразие
целевых платформ и сценариев использования Linux~\cite{McKenneyOSR08}.

В настоящее время RCU широко используется в сетевой, файловой подсистемах
ядра Linux, а также в подсистеме работы с
устройствами~\cite{McKenneyOSR08,McKenneyRCUsageReport13}.
%\url{http://www2.rdrop.com/~paulmck/RCU/linuxusage/linux-4.3.sum}}
На данный момент в мире насчитывается более 75 миллионов
Linux-серверов и 1.4 миллирдов мобильных Android-устройств.
На практике это означает, что даже самая редкая ошибка исходного кода
реализации будет проявлятся недопустимо часто.
В связи с этим, строгая валидация сложных сценариев поведения RCU является
критически важной. В связи с тем, что исчерпывающее тестирование данного
механизма невозможно из-за экпоненциального роста числа сценариев тестирования,
имеет смысл использовать метод формальной верификации.

Основные усилия, направленные с верификацией многопоточного программного
обеспечения, основаны на на тестировании, но, к сожалению, на данный
момент не существует эффективной методики тестирования такого ПО,
способной проверить все возможные сценарии.
Более того, некоторые ошибки, которые обнаруживаются в ходе тестирования,
могут быть трудными для повторного воспроизведения, отладки и исправления.
Многопоточная сущность RCU и огромное пространство возможных сценариев
тестирования наводят на мысль об использовании методов формальной верификации,
в частности, верификации моделей~\cite{BurchInfComput92}.

Следует отметить, что формальные методы уже применялись ранее
для верификации некоторых частей дизайна RCU, например
Tiny RCU~\cite{VerificationChallenges}, userspace RCU~\cite{DesnoyersOSR13},
sysidle~\cite{VerificationChallenges} и взаимодействия между
dyntick-idle и немаскируемыми прерываениями (NMIs)~\cite{ValDyntickNMI}.
% Lihao: correct citations? Paul: Look good. For a more recent NMI/dyntick example:
% \url{https://kernel.googlesource.com/pub/scm/linux/kernel/git/paulmck/linux-rcu/+/andy.2014.11.21a}.}
%
Но эти попытки были направлены либо на верификацию примитивных реализаций
RCU для одноядерных систем (Tiny RCU), либо использовали специализированные
языки описания моделей, такие, как Promela~\cite{HolzmannTSE97SPIN}.
Несмотря на то, что данные языки имеют ряд преимуществ,
основных недостатком их использования в контексте ядра Linux
является сложность ручной трансляции исходного кода.
%
Иные исследователи использовали аппарат формальной логики для
верификации простых реализаций RCU~\cite{YangESOP13RCU,DreyerPLDI15RCU}.
Несмотря на то, что данный подход является весьма интересным,
он требует большего количества работы, нежели трансляция исходного кода.

Более того, цикл разработки ядра Linux составляет около 60 дней,
и в течение каждого из них вносятся правки в RCU.
В связи с этим всякий ручной труд по верификации должен будет
повторяться шесть раз в год, чтобы формальные модели верификации RCU
оставались актуальными.
%
Из этого следует, что для того, чтобы процесс формальной верификации
RCU мог быть включен в набор регрессинных тестов, используемые в нем методы
должны быть автоматизируемыми и масштабируемыми.
% Paul: I say "must be scalable and automated" with the power invested in
% me in my role as Linux-kernel RCU maintainer.  ;-)
%, especially if it is to be applied to the full Linux kernel as opposed to
% the tiny subset of the kernel that is RCU.
%
В этой статье описывается процесс построения модели верификации напрямую из
исходного кода реализации RCU в Linux и использование
C~Bounded Model Checker (CBMC)~\cite{KroeningTACAS04CBMC}
для проверки ее инвариантных свойств.
%
По нашим сведениям, это первая попытка автоматизированной верификации существенной части
исходного кода RCU и важный шаг на пути интеграции процедуры формальной верификации
в набор регрессионных тестов ядра Linux.
