\section{Реализация Tree RCU}\label{sec:tree_rcu}

Основное преимущество RCU заключается в том, что он позволяет
ожидать выхода весьма большого числа потоков-читателей из своих
критических секций без необходимости учета каждого из них:
в ядрах с non-preemptible реализацией многопоточности их число
ограничено количеством ядер процессора,
в ядрах с preemptible реализацией --- неограниченно вовсе.
Несмотря на то, что примитивы чтения RCU обладают замечательными
показателями производительности и масштабируемости,
примитивы записи должны оттягивать фазу освобождения до тех пор,
пока все потоки-читатели не выйдут из своих критических секций,
за счет блокирования или регистрации callback'а, который должен быть
вызван по истечении grace-периода.
Производительность и масштабируемость RCU определяются
эффективности механизмов обнаружения окончания \emph{grace}-периода.
Например, простейшая реализация RCU может требовать,
чтобы каждое ядро процессора использовало глобальную блокировку
для каждого grace-периода, но этот подход существенно снизит
производительность и масштабируемость.
Для реальных систем, имеющих тысячи процессоров и управляемых Linux,
данный подход неприменим. Этот факт послужил причиной создания Tree RCU.

\subsection{Обзор}
% Lihao: include this in PhD thesis; also look for 'preemptible RCU contents'
%There are several flavors of RCU, including RCU-sched, RCU-preempt,
%RCU Bot\-tom-Half, and Sleepable RCU (SRCU)~\cite{MckenneyRCUflavors}.
% Different flavors have different quiescent states, which are
% discussed in Section \ref{sec:quiescent_state}.
%
% Classic RCU has two implementations: Tiny RCU and Tree RCU. Tiny RCU
% is only for uni-processor systems; we therefore focus on Tree RCU in this paper.
% Tree RCU further has non-pre\-emptible and preemptible variants,
% configured by the kernel Kconfig option \co{CONFIG_PREEMPT}.
% There is no preemptible implementation of Tiny RCU: Instead,
% preemptible Tree RCU is used in single-CPU preemptible kernel builds.
%
% Tree RCU implements RCU-sched, RCU-bh, and RCU-preempt when \co{CONFIG_PREEMPT=y}.
% If \co{CONFIG_PREEMPT=n}, then RCU-preempt is mapped into RCU-sched.
% Tiny RCU requires \co{CONFIG_PREEMPT=n}, so it also maps
% RCU-preempt into RCU-sched.
%
Будем рассматривать <<стандартный>> программный интерфейс RCU
в комбинации с non-preemptible версией ядра Linux,
концентрируясь в основном на примитивах
\co{rcu_read_lock()}, \co{rcu_read_unlock()} и \co{synchronize_rcu()}.
%
%\comment{Lihao: it seems the Tree implementation of Classic RCU also
%implements other three flavors: RCU-sched, RCU-bh, and RCU-preempt;
%and Tiny RCU implements RCU-sched and RCU-bh. Am I right?
%Conceptually, what is the relationship between flavors Classic RCU and
%RCU-sched/RCU-bh? I shall discuss their relationship here otherwise
%readers may get confused when we discuss different flavors in the
%Tree RCU implementation in later sections.}
%\comment{Paul:
%	Yes, Tree RCU implements RCU-sched, RCU-bh, and RCU-preempt,
%	but only when \co{CONFIG_PREEMPT=y}.
%	If \co{CONFIG_PREEMPT=n}, then RCU-preempt is mapped into
%	RCU-sched.
%	Because Tiny RCU is requires \co{CONFIG_PREEMPT=n}, it behaves
%	the same as does Tree RCU when \co{CONFIG_PREEMPT=n},
%	implementing RCU-sched and RCU-bh, and mapping RCU-preempt into
%	RCU-sched.
%	For RCU-preempt, any location outside of an RCU read-side
%	critical section is a quiescent state.
%	For RCU-sched, context switch, idle, userspace,
%	\co{cond_resched_rcu_qs()}, and offline are all quiescent
%	states.
%	For RCU-bh, any location where bottom-half execution is enabled
%	is a quiescent state.
%	Use RCU-sched when you need updaters to wait on hardware interrupt
%	handlers (device drivers) or preempt-disable regions (tracing).
%	Use RCU-bh when networking denial-of-service attacks are a potential
%	issue.}
%
% In a non-pre\-empt\-ible kernel, Tiny and Tree RCU use the same
% \co{rcu_read_lock()} and \co{rcu_read_unlock()} implementation.
% Tiny RCU's \co{synchronize_rcu()} implementation is trivial,
% while preemptible and non-pre\-emptible Tree RCU largely share a rather
% elaborate implementation.
%
Основная идея заключается в том, что примитивы чтения RCU являются
частью ядра и поэтому в его non-preemptible конфигурациях не блокируются.
Поэтому каждый раз, когда ядро процессора простаивает в состоянии бездействия
или блокируется в процессе выполнения пользовательских программ,
все критические секции чтения RCU, запущенные ранее на этом ядре,
оказываются завершенными.
Поэтому каждое из этих состояний называется \emph{устойчивым состоянием}.
Каждый такой переход через устойчивое состояние сигнализирует об
окончании соответствующего grace-периода.
%\comment{Paul: Shouldn't the definition of quiescent state be before the
%first use?}
%\comment{Lihao: move here from the Read-Side Primitives subsection}
% \comment{Lihao: add an overview and high-level idea of how the implementation of Tree RCU works.}
Основная сложность заключается в том, чтобы определить момент,
когда все необходимые устойчивые состояния были пройлены для данного
grace-периода, сохранив при этом высокую производительность и масштабируемость.

Например, использование единой структуры данных для регистрации устойчивых
состояний каждого ядра приводит к неприемлемо частому использованию
блокировок на крупных системах, что в свою очередь приводит к снижению
производительности.
Для решения этой проблемы Tree RCU использует иерархическую организацию
структур данных, каждый узел которой предназначен для учета устойчивых
состояний отдельного ядра и предоставляет свою информацию более высоким уровням.
По достижении корня дерева grace-период заканчивается и
его информация распространяется по всем узлам-потомкам.
Вскоре после того, как узлы получают данную информацию,
происходит возврат из \co{synchronize_rcu()}.

В оставшейся части данного раздела мы рассмотрим реализацию Tree RCU
в non-preemptible конфигурации ядра Linux версии 4.3.6.
Вначале мы вкратце опишем реализацию примитивов чтения и записи,
затем опишем иерархическую структуру данных, используемую для эффективного
учета устойчивых состояния, и, наконец, рассмотрим, как RCU использует
эту структуру данных для фиксации устойчивых состояний и grace-периодов
без учета отдельных потоков-читателей.

\input{api_impl}
\input{data_structure}
\input{quiescent_state_detection}
\input{grace_period_detection}
\input{running_example}
